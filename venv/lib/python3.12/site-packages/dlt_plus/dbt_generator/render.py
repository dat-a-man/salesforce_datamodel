import os

from typing import Dict, Any, List, Optional

from dlt import Pipeline
from dlt.common.schema.utils import is_complete_column

from jinja2 import Environment, PackageLoader
from dlt_plus.dbt_generator.config import (
    Config,
    TESTS_FOLDER,
    MACROS_FOLDER,
    ANALYSIS_FOLDER,
    STAGING_MODELS_FOLDER,
    MARTS_MODELS_FOLDER,
)

from dlt_plus.dbt_generator.utils import get_table_info, Table, Relationship


class FilesExistException(Exception):
    def __init__(self, path: str) -> None:
        super().__init__("Item(s) at path {path} exist, use the --force flag to allow overwriting")


def _protect_overwrite(path: str, config: Config) -> None:
    if os.path.exists(os.path.join(path)) and not config.force:
        raise FilesExistException(path)


def _render_template(
    folder: str, template_name: str, output_location: str, vars: Dict[str, Any] = {}
) -> None:
    jinja_env = Environment(loader=PackageLoader("dlt_plus.dbt_generator"))
    template = jinja_env.get_template(template_name)
    if folder:
        output_location = os.path.join(folder, output_location)
    with open(output_location, "w") as f:
        f.write(template.render(**vars))


def _create_project_folders(config: Config) -> None:
    # folder
    for folder in [
        STAGING_MODELS_FOLDER,
        MARTS_MODELS_FOLDER,
        MACROS_FOLDER,
        ANALYSIS_FOLDER,
        TESTS_FOLDER,
    ]:
        f = os.path.join(config.destination_root_folder, folder)
        os.makedirs(f, exist_ok=True)


def render_fact_table(pipeline: Pipeline, config: Config) -> str:
    # folder
    _create_project_folders(config)

    # get relationship info from schema
    #
    relationships = get_table_info(config.tables_to_render)

    # collect all tables in table tree
    relevant_tables: List[Table] = []

    def _add_rendered_column(table_name: str, column_name: str) -> None:
        table_def = relationships[table_name]
        if column_name not in table_def.render_columns:
            table_def.render_columns.append(column_name)

    def _append_relevant_tables(
        table_name: str,
        parent_relationship: Optional[Relationship] = None,
        parent_table: Optional[Table] = None,
    ):
        table_def = relationships[table_name].model_copy()
        # build relationship hierarchy
        if parent_relationship:
            table_def.parent_relationship = parent_relationship
            table_def.parent_table = parent_table
            key_chain = [parent_relationship.relating_table_key]
            while parent_table:
                if pr := parent_table.parent_relationship:
                    key_chain.append(pr.relating_table_key)
                parent_table = parent_table.parent_table
            keys = "_".join(key_chain)
            table_def.alias = f"{table_def.name}_{keys}"
        relevant_tables.append(table_def)
        _add_rendered_column(table_name, table_def.primary_key)
        for _, rels in table_def.relationships.items():
            for rel in rels:
                _append_relevant_tables(
                    rel.related_table, parent_relationship=rel, parent_table=table_def
                )

    _append_relevant_tables(config.fact_table)

    # we need to add all columns of the fact table to be selected and rendered
    fact_table = relevant_tables[0]
    fact_table.render_columns = fact_table.all_data_columns
    if fact_table.primary_key not in fact_table.render_columns:
        fact_table.render_columns.insert(0, fact_table.primary_key)

    for table in relevant_tables:
        table.suggested_columns = [
            col for col in table.all_data_columns if col not in table.render_columns
        ]

    # mapping of plain table names to sources in facts and dimension tables
    table_sources: Dict[str, str] = {}
    for table in relevant_tables:
        if table.name == config.fact_table:
            source = f"stg_{config.project_name}__{table.name}"
        else:
            source = f"dim_{config.project_name}__{table.name}"
        table_sources[table.name] = source

    # output name
    fact_name = f"fact_{config.project_name}__{config.fact_table}.sql"
    location = os.path.join(config.mart_models_folder, fact_name)

    # protect from overwriting the whole project
    _protect_overwrite(location, config)

    _render_template(
        folder=config.mart_models_folder,
        template_name="table_fact.sql.j2",
        output_location=fact_name,
        vars={
            "table_sources": table_sources,
            "fact_table_name": config.fact_table,
            "relevant_tables": relevant_tables,
        },
    )

    return location


def render_dbt_project(pipeline: Pipeline, config: Config) -> str:
    # folder
    _protect_overwrite(config.destination_root_folder, config)
    _create_project_folders(config)

    # render main file
    _render_template(
        folder=config.base_folder,
        template_name="main.py.j2",
        output_location=config.main_file_name,
        vars={
            "pipeline_name": config.project_name,
            "dbt_package_location": config.package_name,
            "destination": config.destination,
        },
    )

    # TODO: allow for pipelines with many schemas by ie. rendering separate staging and marts

    _render_template(
        folder=config.base_folder,
        template_name="README.md.j2",
        output_location="README.md",
        vars={"project_name": config.project_name, "tables": config.tables_to_render},
    )

    active_load_id_table_name = f"{config.project_name}_dlt_active_load_ids"
    processed_load_id_table_name = f"{config.project_name}_dlt_processed_load_ids"

    # render requirements file
    _render_template(
        folder=config.destination_root_folder,
        template_name="requirements.txt.j2",
        output_location="requirements.txt",
    )

    # main dbt project file
    _render_template(
        folder=config.destination_root_folder,
        template_name="dbt_project.yml.j2",
        output_location="dbt_project.yml",
        vars={
            "project_name": config.project_name,
        },
    )

    _render_template(
        folder=config.staging_models_folder,
        template_name="sources.yml.j2",
        output_location="sources.yml",
        vars={
            "tables": config.tables_to_render,
            "processed_load_id_table_name": processed_load_id_table_name,
        },
    )

    mart_table_names: List[str] = []

    # render tables
    for table_name, table in config.tables_to_render.items():
        stage_name = f"stg_{config.project_name}__{table_name}"
        mart_name = f"dim_{config.project_name}__{table_name}"
        parent_stage_name = None
        if parent_table := table.get("parent"):
            parent_stage_name = f"stg_{config.project_name}__{parent_table}"

        mart_table_names.append(mart_name)

        # get column names for all complete columns
        columns = [c.get("name") for c in filter(is_complete_column, table["columns"].values())]

        template_vars = {
            "table_name": table_name,
            "stg_table_name": stage_name,
            "description": table.get("description", ""),
            "parent": table.get("parent"),
            "columns": columns,  # type: ignore
            "active_table_name": active_load_id_table_name,
            "is_data_table": not table_name.startswith("_dlt"),
            "parent_stage_name": parent_stage_name,
        }

        _render_template(
            folder=config.staging_models_folder,
            template_name="table_staging.sql.j2",
            output_location=f"{stage_name}.sql",
            vars=template_vars,
        )

        _render_template(
            folder=config.mart_models_folder,
            template_name="table_mart.sql.j2",
            output_location=f"{mart_name}.sql",
            vars=template_vars,
        )

    # render active load id's table
    _render_template(
        folder=config.models_folder,
        template_name="table_active_load_ids.sql.j2",
        output_location=f"{active_load_id_table_name}.sql",
        vars={
            "tables": config.tables_to_render,
            "processed_load_id_table_name": processed_load_id_table_name,
        },
    )

    # render processed load id's table
    _render_template(
        folder=config.models_folder,
        template_name="table_processed_load_ids.sql.j2",
        output_location=f"{processed_load_id_table_name}.sql",
        vars={
            "mart_table_names": mart_table_names,
            "active_table_name": active_load_id_table_name,
        },
    )

    return config.destination_root_folder
