import os

from dataclasses import dataclass
from dlt import Pipeline
from dlt.common.schema.utils import has_table_seen_data

TESTS_FOLDER = "tests"
MACROS_FOLDER = "macros"
ANALYSIS_FOLDER = "analysis"
MODELS_FOLDER = "models"
STAGING_MODELS_FOLDER = os.path.join(MODELS_FOLDER, "staging")
MARTS_MODELS_FOLDER = os.path.join(MODELS_FOLDER, "marts")


@dataclass
class Config:
    base_folder: str = "./"

    include_dlt_tables: bool = False
    fact_table: str = ""
    force: bool = False
    """Allows overwrite without question"""

    def update_from_pipeline(self, pipeline: Pipeline) -> None:
        self.project_name = pipeline.pipeline_name
        self.schema = pipeline.default_schema
        self.destination = pipeline.destination.to_name(pipeline.destination)
        self.package_name = f"dbt_{self.project_name}"
        self.destination_root_folder = os.path.join(self.base_folder, self.package_name)
        self.main_file_name = f"run_{self.project_name}_dbt.py"
        self.staging_models_folder = os.path.join(
            self.destination_root_folder, STAGING_MODELS_FOLDER
        )
        self.mart_models_folder = os.path.join(self.destination_root_folder, MARTS_MODELS_FOLDER)
        self.models_folder = os.path.join(self.destination_root_folder, MODELS_FOLDER)
        # filter eligible tables, _dlt_loads_id must always be included
        self.tables_to_render = {
            name: table
            for name, table in self.schema.tables.items()
            if (has_table_seen_data(table) and not name.startswith(self.schema._dlt_tables_prefix))
            or name == self.schema.loads_table_name
            or (self.include_dlt_tables and name.startswith(self.schema._dlt_tables_prefix))
        }
